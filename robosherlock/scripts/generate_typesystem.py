#!/usr/bin/python

import sys, os
import xml.dom.minidom
import check_modification

################################################################################
# Templates
################################################################################

# C++ header template
# 0: header info
# 1: header define
# 2: additional includes
# 3: namespace
# 4: class definitions
# 5: type traits
HEADER =\
r"""{0}
#ifndef {1}
#define {1}

#include <robosherlock/feature_structure_proxy.h>
{2}
namespace {3}
{{

{4}}}

{5}
#endif /* {1} */
"""

# C++ header information template
# 0: generation script file name
# 1: filename
# 2: sub namespace
# 3: description
# 4: version
# 5: vendor
HEADER_INFO =\
r"""/*
 * This file was generated by {0}.
 * Filename:    {1}
 * Name:        {2}
 * Description: {3}
 * Version:     {4}
 * Vendor:      {5}
 */"""

# C++ define template
# 0: header filename in upper case
DEFINE = "__{0}_H__"

# C++ type include template
# 0: header filename
INCLUDE = "#include <{0}>\n"

# C++ class template
# 0: description
# 1: class name
# 2: base class
# 3: fields
# 4: field initializations
CLASS =\
r"""/*
 * {0}
 */
class {1} : public {2}
{{
private:
  void initFields()
  {{
{4}  }}
public:
{3}
  {1}(const {1} &other) :
      {2}(other)
  {{
    initFields();
  }}

  {1}(uima::FeatureStructure fs) :
      {2}(fs)
  {{
    initFields();
  }}
}};

"""

# C++ field template
# 0: description
# 1: type
# 2: type name
FIELD = "  // {0}\n  {1} {2};\n"

# C++ field initialization template
# 0: field name
FIELD_INIT = "    {0}.init(this, \"{0}\");\n"

# Special id initialization
FIELD_ID_INITIALIZATION =\
r"""    if(id().empty())
    {
      id(::mongo::OID::gen().toString());
    }
"""

# C++ type with namespace template
# 0: namespace
# 1: type
TYPE_NS = "{0}::{1}"

# C++ type trait template
# 0: namespace
# 1: class name
# 2: definition
TYPE_TRAIT = "TYPE_TRAIT({0}::{1}, {2})\n"

# C++ type definitions name
TYPE_DEFINITIONS_NAME = "type_definitions"

# C++ type definitions template
# 0: generation script file name
# 1: header define
# 2: definitions
TYPE_DEFINITIONS =\
r"""/*
 * This file was generated by {0}.
 */
#ifndef {1}
#define {1}

{2}
#endif /* {1} */
"""

# C++ type definition template
# 0: definition
# 1: string value
TYPE_DEFINITION = "#define {0} \"{1}\"\n"

# C++ type definition name template
# 0: namespace in upper case
# 1: sub namespace in upper case
# 2: class name in upper case
TYPE_DEFINITION_NAME = "{0}_{1}_{2}"

# UIMA type name template
# 0: namespace
# 1: sub namespace
# 2: class name
TYPE_FULL_NAME = "{0}.{1}.{2}"

# C++ all types template
# 0: generation script file name
# 1: header define
# 2: includes
ALL_TYPES = \
r"""/*
 * This file was generated by {0}.
 */
#ifndef {1}
#define {1}

{2}

#endif /* {1} */
"""

# C++ all types name
ALL_TYPES_NAME = "all_types"

################################################################################
# UIMA to C++ types
################################################################################

# C++ default feature structure super type
DEFAULT_UIMA_SUPERTYPE = "uima.cas.TOP"
DEFAULT_C_SUPERTYPE = "FeatureStructureProxy"
DEFAULT_NAMESPACE = "rs"

# C++ feature structure types
# 0: element type
BASE_TYPE =    "FeatureStructureEntry<{0}>"
ARRAY_TYPE =   "ArrayFeatureStructureEntry<{0}>"
LIST_TYPE =    "ListFeatureStructureEntry<{0}>"
COMPLEX_TYPE = "ComplexFeatureStructureEntry<{0}>"

# UIMA base types to C++ types map
BASE_TYPES = {
  "uima.cas.Boolean" : "bool",
  "uima.cas.Byte"    : "char",
  "uima.cas.Short"   : "short",
  "uima.cas.Integer" : "int",
  "uima.cas.Long"    : "INT64",
  "uima.cas.Float"   : "float",
  "uima.cas.Double"  : "double",
  "uima.cas.String"  : "std::string"
}

# UIMA array types to C++ types map
ARRAY_TYPES = {
  "uima.cas.BooleanArray" : "bool",
  "uima.cas.ByteArray"    : "char",
  "uima.cas.ShortArray"   : "short",
  "uima.cas.IntegerArray" : "int",
  "uima.cas.LongArray"    : "INT64",
  "uima.cas.FloatArray"   : "float",
  "uima.cas.DoubleArray"  : "double",
  "uima.cas.StringArray"  : "std::string",
  "uima.cas.FSArray"      : None
}

# UIMA list types to C++ types map
LIST_TYPES = {
  "uima.cas.IntegerList"         : "int",
  "uima.cas.FloatList"           : "float",
  "uima.cas.StringList"          : "std::string",
  "uima.cas.FSList"              : None,
  "uima.cas.EmptyFloatList"      : "float",
  "uima.cas.EmptyIntegerList"    : "int",
  "uima.cas.EmptyStringList"     : "std::string",
  "uima.cas.EmptyFSList"         : None,
  "uima.cas.NonEmptyFloatList"   : "float",
  "uima.cas.NonEmptyIntegerList" : "int",
  "uima.cas.NonEmptyStringList"  : "std::string",
  "uima.cas.NonEmptyFSList"      : None
}

SUPER_TYPES = {
#  "uima.cas.ArrayBase"           : None,
#  "uima.cas.ListBase"            : None,
  "uima.cas.TOP"                 : None,
#  "uima.cas.AnnotationBase"      : None,
  "uima.tcas.Annotation"         : None,
  "uima.tcas.DocumentAnnotation" : None,
  "uima.cas.SofaFS"              : None
}

################################################################################
# __str__ Templates
################################################################################

# __str__ TypeSystem template
# 0: __str__ of SubTypeSystems
STR_TYPESYSTEM = \
r"""SubTypeSystems:
{0}"""

# __str__ SubTypeSystem template
# 0: filename
# 1: name
# 2: description
# 3: version
# 4: vendor
# 5: imports
# 6: dependencies
# 7: __str__ of Types
STR_SUBTYPESYSTEM = \
r"""  Filename:     {0}
  Name:         {1}
  Description:  {2}
  Version:      {3}
  Vendor:       {4}
  Project:      {5}
  Namespace:    {6}
  XML Path:     {7}
  CPP Path:     {8}
  Include Path: {9}
  Imports:
{10}  Dependencies:
{11}  Types:
{12}"""

# __str__ Type template
# 0: name
# 1: description
# 2: super type
# 3: dependencies
# 4: __str__ of Features
STR_TYPE = \
r"""    Name:        {0}
    Description: {1}
    Supertype:   {2}
    Dependencies:
{3}    Features:
{4}"""

# __str__ SubTypeSystem template
# 0: name
# 1: description
# 2: range type
# 3: multiple references allowed
# 4: element type
STR_FEATURE = \
r"""      Name:          {0}
      Description:   {1}
      Rangetype:     {2}
      MulRefAllowed: {3}
      ElementType:   {4}
"""

# __str__ import template
# 0: import file name
STR_IMPORT = "    {0}\n"

# __str__ dependency template
# 0: dependency name
STR_DEPENDENCY = "      {0}\n"

################################################################################
# All types xml template
################################################################################

# all types xml template
# 0: namespace
# 1: imports
XML_ALL_TYPES = \
r"""<?xml version="1.0" encoding="UTF-8"?>
<typeSystemDescription xmlns="http://uima.apache.org/resourceSpecifier">
  <name>{0}</name>
  <description/>
  <version>1.0</version>
  <vendor/>
  <imports>{1}
  </imports>
</typeSystemDescription>
"""

# import xml template
# 1: path to xml file
XML_IMPORT = "\n    <import location=\"{0}\"/>"

# import autogen message
XML_AUTOGEN = "\n    <!-- THESE IMPORTS WILL BE AUTOMATICALLY GENERATED BY A SCRIPT -->"

################################################################################
# Order by dependencies
################################################################################

def addToOrderedList(items, ordered, item):
  if item.name in ordered:
    return

  for dep in item.dependencies:
    addToOrderedList(items, ordered, items[dep])

  ordered.append(item.name)
  return

def orderByDependencies(items):
  ordered = []

  # items with no dependencies first
  for item in items.values():
    if len(item.dependencies) == 0 :
      addToOrderedList(items, ordered, item)

  for item in items.values():
    addToOrderedList(items, ordered, item)
  return ordered

################################################################################
# Project
################################################################################

class Project:
  def __init__(self, name, namespace, xmlPath, cppPath, includePath):
    self.name = name
    self.namespace = namespace
    self.xmlPath = xmlPath
    self.cppPath = cppPath
    self.includePath = includePath
    self.files = []
    return

  def addXMLFile(self, filename):
    self.files.append(filename)

################################################################################
# TypeSystem
################################################################################

class TypeSystem:
  def __init__(self):
    self.subTypeSystems = {}
    return

  def __str__(self):
    strSTS = ""
    ordered = orderByDependencies(self.subTypeSystems)
    for key in ordered:
      sts = self.subTypeSystems[key]
      strSTS += str(sts)
    return STR_TYPESYSTEM.format(strSTS)

  def addSubTypeSystem(self, ts):
    self.subTypeSystems[ts.name] = ts

  def check(self):
    ret = True
    for sts in self.subTypeSystems.values():
      ret = sts.checkTypes() and ret
    return self.checkTypes() and ret

  def checkTypes(self):
    types = {}
    ret = True
    for sts in self.subTypeSystems.values():
      for t in sts.types.values():
        if t.name in types:
          print("error: {0}.xml: type {1} already defined in {2}.xml".format(sts.filename, t.name, types[t.name].filename))
          ret = False
        else:
          types[t.name] = sts
    return ret

  def format(self, project):
    files = {}
    definitions = ""
    definitionsName = TYPE_DEFINITIONS_NAME + ".h"
    allTypesName = ALL_TYPES_NAME + ".h"
    allTypes = INCLUDE.format(os.path.join(project.includePath, definitionsName))

    ordered = orderByDependencies(self.subTypeSystems)
    for key in ordered:
      sts = self.subTypeSystems[key]
      if sts.project.name != project.name:
        continue
      (filename, content, definition) = sts.format()
      filename += ".h"
      files[filename] = content
      allTypes += INCLUDE.format(os.path.join(sts.project.includePath, filename))
      definitions += definition

    script = os.path.basename(sys.argv[0])

    define = DEFINE.format(project.name.upper() + "_" + TYPE_DEFINITIONS_NAME.upper())
    files[definitionsName] = TYPE_DEFINITIONS.format(script, define, definitions)

    define = DEFINE.format(project.name.upper() + "_" + ALL_TYPES_NAME.upper())
    files[allTypesName] = ALL_TYPES.format(script, define, allTypes)

    return files

################################################################################
# SubTypeSystem
################################################################################

class SubTypeSystem:
  def __init__(self, parent, filename, name, description, version, vendor, project):
    self.parent = parent
    self.project = project
    self.filename = filename
    self.name = name
    if description:
      self.description = description
    else:
      self.description = "No description given"
    self.version = version
    self.vendor = vendor
    self.types = {}
    self.imports = []
    self.dependencies = []
    parent.addSubTypeSystem(self)

  def __str__(self):
    strI = ""
    strD = ""
    strT = ""
    if len(self.imports) == 0:
      strI = STR_IMPORT.format("None")
    else:
      for i in self.imports:
        strI += STR_IMPORT.format(i)
    if len(self.dependencies) == 0:
      strD = STR_IMPORT.format("None")
    else:
      for i in self.dependencies:
        strD += STR_IMPORT.format(i)

    ordered = orderByDependencies(self.types)
    for key in ordered:
      t = self.types[key]
      strT += str(t)
    return STR_SUBTYPESYSTEM.format(self.filename, self.name, self.description, self.version, self.vendor,
                                    self.project.name, self.project.namespace, self.project.xmlPath,
                                    self.project.cppPath, self.project.includePath, strI, strD, strT)

  def addType(self, t):
    self.types[t.name] = t

  def addImport(self, location):
    self.imports.append(location)

  def addDependency(self, dependency):
    splitD = dependency.split('.')
    if len(splitD) != 3:
      raise Exception("type name in wrong format.")

    if not splitD[1] in self.dependencies:
      self.dependencies.append(splitD[1])

  def checkTypes(self):
    ret = True
    keys = self.types.keys()
    for t in self.types.values():
      for dep in t.dependencies:
        if not dep in keys:
          ret = False
          print("error: {0}.xml: {1} uses unknown local type {2}.".format(self.filename, t.name, dep))
      for (sts, dep) in t.gloablDependencies:
        if not sts in self.parent.subTypeSystems or not dep in self.parent.subTypeSystems[sts].types:
          ret = False
          print("error: {0}.xml: {1} uses unknown global type {2}.{3}.".format(self.filename, t.name, sts, dep))
    return ret

  def format(self):
    script = os.path.basename(sys.argv[0])
    info = HEADER_INFO.format(script, self.filename, self.name, self.description, self.version, self.vendor)

    define = DEFINE.format(self.filename.upper())
    includes = INCLUDE.format(os.path.join(self.project.includePath, TYPE_DEFINITIONS_NAME + ".h"))
    typeTraits = ""
    definitions = ""
    classes = ""

    for dep in self.dependencies:
      sts = self.parent.subTypeSystems[dep]
      filename = os.path.join(sts.project.includePath, sts.filename + ".h")
      includes += INCLUDE.format(filename)

    ordered = orderByDependencies(self.types)
    for key in ordered:
      t = self.types[key]
      (content, typeTrait, definition) = t.format()
      classes += content
      typeTraits += typeTrait
      definitions += definition

    header = HEADER.format(info, define, includes, self.project.namespace, classes, typeTraits)
    return (self.filename, header, definitions)

################################################################################
# Type
################################################################################

class Type:
  def __init__(self, parent, name, description, supertype):
    self.parent = parent
    self.name = name
    self.features = []
    self.dependencies = []
    self.gloablDependencies = []
    if description:
      self.description = description
    else:
      self.description = "No description given"

    if DEFAULT_NAMESPACE != parent.project.namespace:
      defautCSupertype = TYPE_NS.format(DEFAULT_NAMESPACE, DEFAULT_C_SUPERTYPE)
    else:
      defautCSupertype = DEFAULT_C_SUPERTYPE

    if supertype == DEFAULT_UIMA_SUPERTYPE:
      self.supertype = defautCSupertype
    elif supertype in SUPER_TYPES and not SUPER_TYPES[supertype]:
      warning = "warning: in {0} supertype defined as {1} may not be supported properly. using default {2}."
      print(warning.format(name, supertype, DEFAULT_C_SUPERTYPE))
      self.supertype = defautCSupertype
    else:
      self.addDependency(supertype)
      typeSplit = supertype.split(".")
      if typeSplit[0] != parent.project.namespace:
        self.supertype = TYPE_NS.format(typeSplit[0], typeSplit[2])
      else:
        self.supertype = typeSplit[2]
    parent.addType(self)

  def __str__(self):
    strD = ""
    strF = ""
    if len(self.dependencies) == 0:
      strD = STR_DEPENDENCY.format("None")
    else:
      for i in self.dependencies:
        strD += STR_DEPENDENCY.format(i)
    for f in self.features:
      strF += str(f)
    return STR_TYPE.format(self.name, self.description, self.supertype, strD, strF)

  def addFeature(self, f):
    self.features.append(f)

  def addDependency(self, dependency):
    splitD = dependency.split('.')
    if len(splitD) != 3:
      raise Exception("type name in wrong format.")

    if splitD[1] == self.parent.name and splitD[2] == self.name:
      pass # Possible circular dependency to itself, but it may work
    elif splitD[1] == self.parent.name:
      if not dependency in self.dependencies:
        self.dependencies.append(splitD[2])
    else:
      self.gloablDependencies.append((splitD[1], splitD[2]))
      self.parent.addDependency(dependency)

  def format(self):
    fields = ""
    fieldInits = ""
    namespace = self.parent.project.namespace
    subNamespace = self.parent.name
    definitionName = TYPE_DEFINITION_NAME.format(namespace.upper(), subNamespace.upper(), self.name.upper())
    fullname = TYPE_FULL_NAME.format(namespace, subNamespace, self.name)
    typeTrait = TYPE_TRAIT.format(namespace, self.name, definitionName)
    definition = TYPE_DEFINITION.format(definitionName, fullname)
    for f in self.features:
      (field , fieldInit) = f.format()
      fields += field
      fieldInits += fieldInit

    content = CLASS.format(self.description, self.name, self.supertype, fields, fieldInits)
    return (content, typeTrait, definition)

################################################################################
# Feature
################################################################################

class Feature:
  def __init__(self, parent, name, description, rangetype, multipleReferencesAllowed, elementType):
    self.parent = parent
    self.name = name
    if description:
      self.description = description
    else:
      self.description = "No description given"
    self.rangetype = rangetype
    self.multipleReferencesAllowed = multipleReferencesAllowed
    self.elementType = elementType

    if self.rangetype in BASE_TYPES:
      self.cType = BASE_TYPE.format(BASE_TYPES[self.rangetype])
    elif self.rangetype in ARRAY_TYPES:
      aType = ARRAY_TYPES[self.rangetype]
      if aType:
        self.cType = ARRAY_TYPE.format(aType)
      elif self.rangetype in SUPER_TYPES and not SUPER_TYPES[self.rangetype]:
        warning = "warning: in {0} rangetype defined as {1} may not be supported properly. using default {2}."
        print(warning.format(name, rangetype, DEFAULT_C_SUPERTYPE))
        self.cType = ARRAY_TYPE.format(DEFAULT_C_SUPERTYPE)
      else:
        parent.addDependency(self.elementType)
        typeSplit = self.elementType.split(".")
        if typeSplit[0] != parent.parent.project.namespace:
          self.cType = ARRAY_TYPE.format(TYPE_NS.format(typeSplit[0], typeSplit[2]))
        else:
          self.cType = ARRAY_TYPE.format(typeSplit[2])
    elif self.rangetype in LIST_TYPES:
      lType = LIST_TYPES[self.rangetype]
      if lType:
        self.cType = LIST_TYPE.format(lType)
      elif self.rangetype in SUPER_TYPES and not SUPER_TYPES[self.rangetype]:
        warning = "warning: in {0} rangetype defined as {1} may not be supported properly. using default {2}."
        print(warning.format(name, rangetype, DEFAULT_C_SUPERTYPE))
        self.cType = ARRAY_TYPE.format(DEFAULT_C_SUPERTYPE)
      else:
        parent.addDependency(self.elementType)
        typeSplit = self.elementType.split(".")
        if typeSplit[0] != parent.parent.project.namespace:
          self.cType = LIST_TYPE.format(TYPE_NS.format(typeSplit[0], typeSplit[2]))
        else:
          self.cType = LIST_TYPE.format(typeSplit[2])
    elif self.rangetype in SUPER_TYPES and not SUPER_TYPES[self.rangetype]:
      warning = "warning: in {0} rangetype defined as {1} may not be supported properly. using default {2}."
      print(warning.format(name, rangetype, DEFAULT_C_SUPERTYPE))
      self.cType = COMPLEX_TYPE.format(DEFAULT_C_SUPERTYPE)
    else:
      parent.addDependency(self.rangetype)
      typeSplit = self.rangetype.split(".")
      if typeSplit[0] != parent.parent.project.namespace:
        self.cType = COMPLEX_TYPE.format(TYPE_NS.format(typeSplit[0], typeSplit[2]))
      else:
        self.cType = COMPLEX_TYPE.format(typeSplit[2])
    if DEFAULT_NAMESPACE != parent.parent.project.namespace:
      self.cType = TYPE_NS.format(DEFAULT_NAMESPACE, self.cType)

    parent.addFeature(self)

  def __str__(self):
    return STR_FEATURE.format(self.name, self.description, self.rangetype, self.multipleReferencesAllowed, self.elementType)

  def format(self):
    field = FIELD.format(self.description, self.cType, self.name)
    fieldInit = FIELD_INIT.format(self.name)
    if self.name == "id":
      fieldInit += FIELD_ID_INITIALIZATION

    return (field , fieldInit)

################################################################################
# TypeSystemReader
################################################################################

class TypeSystemReader:
  def __init__(self):
    self.ts = TypeSystem()
    return

  def _getFirstElement(self, elem, name):
    elems = elem.getElementsByTagName(name)
    if len(elems) > 0:
      return elems[0]
    return None

  def _getTextAux(self, node):
    if node and node.firstChild:
      return node.firstChild.nodeValue
    return None

  def _getText(self, elem, name):
    return self._getTextAux(self._getFirstElement(elem, name))

  def _readSubTypeSystem(self, elem, filename, project):
    name = self._getText(elem, "name")
    description = self._getText(elem, "description")
    if description:
      description = description.replace("\n", " ")
    version = self._getText(elem, "version")
    vendor = self._getText(elem, "vendor")
    sts = SubTypeSystem(self.ts, filename, name, description, version, vendor, project)

    imports = elem.getElementsByTagName("import")
    for i in imports:
      if not i.hasAttribute("location"):
        raise Exception("No import location defined in {0}".format(filename))
      filepath = i.getAttribute("location")
      location = os.path.splitext(os.path.basename(filepath))[0]
      sts.addImport(location)

    types = elem.getElementsByTagName("typeDescription")
    for t in types:
      self._readType(t, sts)
    return sts

  def _readType(self, elem, sts):
    name = self._getText(elem, "name")
    description = self._getText(elem, "description")
    if description:
      description = description.replace("\n", " ")
    supertype = self._getText(elem, "supertypeName")
    if len(supertype.split(".")) != 3:
      raise Exception("supertype name does not match naming scheme in {}.{}.{}".format(sts.project.namespace, sts.name, name))

    words = name.split(".")
    if len(words) != 3:
      raise Exception("name does not match naming scheme in {}.{}.{}".format(sts.project.namespace, sts.name, name))
    elif words[0] != sts.project.namespace:
      raise Exception("name does not contain right namespace in {}.{}.{}".format(sts.project.namespace, sts.name, name))
    elif words[1] != sts.name:
      raise Exception("name does not contain right base name in {}.{}.{}".format(sts.project.namespace, sts.name, name))
    name = words[2]

    t = Type(sts, name, description, supertype)

    features = elem.getElementsByTagName("featureDescription")
    for f in features:
      self._readFeature(f, t)
    return t

  def _readFeature(self, elem, t):
    name = self._getText(elem, "name")
    description = self._getText(elem, "description")
    if description:
      description = description.replace("\n", " ")
    rangetype = self._getText(elem, "rangeTypeName")

    allowed = self._getText(elem, "multipleReferencesAllowed")
    allowed = allowed == None or allowed.lower() != "false"
    elementType = self._getText(elem, "elementType")

    if rangetype in ARRAY_TYPES and not ARRAY_TYPES[rangetype] and not elementType:
      fullname = TYPE_FULL_NAME.format(t.parent.project.namespace, t.parent.name, t.name)
      raise Exception("FSArray element type in {0}::{1} not defined".format(fullname, name))
    if rangetype in LIST_TYPES and not LIST_TYPES[rangetype] and not elementType:
      fullname = TYPE_FULL_NAME.format(t.parent.project.namespace, t.parent.name, t.name)
      raise Exception("FSList element type in {0}::{1} not defined".format(fullname, name))

    return Feature(t, name, description, rangetype, allowed, elementType)

  def read(self, projects):
    for project in projects:
      for filename in project.files:
        print("Reading file: " + filename)
        dom = xml.dom.minidom.parse(os.path.join(project.xmlPath, filename))
        self._readSubTypeSystem(dom, os.path.splitext(filename)[0], project)
    return

  def getTypeSystem(self):
    return self.ts

################################################################################
# TypeSystemWriter
################################################################################

class TypeSystemWriter:
  def __init__(self, ts, project):
    self.ts = ts
    self.project = project
    return

  def write(self):
    files = self.ts.format(self.project)

    for filename in files.keys():
      print("Writing file: " + filename)
      content = files[filename]
      out = open(os.path.join(self.project.cppPath, filename), "w")
      out.write(content)
      out.close()
    return

  def writeAllTypesXML(self):
    imports = XML_AUTOGEN

    for filename in self.project.files:
      imports += XML_IMPORT.format(filename)
    xmlFile = XML_ALL_TYPES.format(self.project.namespace, imports)

    print("writing " + ALL_TYPES_NAME + ".xml")

    out = open(os.path.join(self.project.xmlPath, ALL_TYPES_NAME + ".xml"), "w")
    out.write(xmlFile)
    out.close()
    return

  def updateImports(self):
    for sts in self.ts.subTypeSystems.values():
      if not sts.project.name == self.project.name:
        continue

      imports = XML_AUTOGEN
      for dep in sts.dependencies:
        dsts = self.ts.subTypeSystems[dep]
        imports += XML_IMPORT.format(os.path.relpath(os.path.join(dsts.project.xmlPath, dsts.filename + ".xml"), self.project.xmlPath))

      print("updating " + sts.filename + ".xml")

      filepath = os.path.join(self.project.xmlPath, sts.filename + ".xml")
      xml = open(filepath, "r")
      content = xml.read()
      xml.close()

      (start,imports_start,_) = content.partition("<imports>")
      (_,imports_end,end) = content.partition("</imports>")

      content = start + imports_start + imports + "\n  " + imports_end + end
      xml = open(filepath, "w")
      xml.write(content)
      xml.close()

    return

################################################################################
# main
################################################################################

def main():
  if len(sys.argv) < 2:
    help()
    return -1

  projects = []
  files = []
  try:
    for i in range(1, len(sys.argv)):
      args = tuple(sys.argv[i].split(':'))
      if(len(args) != 4):
        sys.stderr.write("Error: {0} not in the right format!".format(sys.argv[i]))
        return -1
      (name,namespace,xmlPath,cppPath) = args
      xmlPath = os.path.abspath(xmlPath)
      cppPath = os.path.abspath(cppPath)
      if not os.path.exists(xmlPath) or not os.path.isdir(xmlPath):
        raise Exception("Path does not exist: " + xmlPath)
      if not os.path.exists(cppPath):
        os.mkdir(cppPath)

      includePath = cppPath.rpartition("include/")[2]
      project = Project(name, namespace, xmlPath, cppPath, includePath)
      projects.append(project)
  except Exception as e:
    sys.stderr.write("Error: " + e.message)
    return -1

  print("Searching for files...")
  for project in projects:
    for filename in os.listdir(project.xmlPath):
      filepath = os.path.join(project.xmlPath, filename)
      if not os.path.isfile(filepath):
        #print("Ignoring file: " + filename)
        continue

      (name, ext) = os.path.splitext(filename)
      if ext != ".xml" or name == ALL_TYPES_NAME:
        #print("Ignoring file: " + filename)
        continue
      project.addXMLFile(filename)
      files.append(filepath)

  print("Checking for modification...")
  if check_modification.isModified(files):
    print("Files modified. Updating type system...")
  else:
    print("Files not modified. Nothing to do.")
    return 0

  print("Reading typesystem...")
  reader = TypeSystemReader()
  try:
    reader.read(projects)
  except Exception as e:
    sys.stderr.write("Error: " + e.message)
    return -1

  ts = reader.getTypeSystem()
  print("checking type system...")
  if not ts.check():
    sys.stderr.write("failed!")
    return -1

  print("Writing typesystem...")
  writer = TypeSystemWriter(ts, projects[0])
  try:
    writer.write()
    writer.writeAllTypesXML()
    writer.updateImports()
  except Exception as e:
    sys.stderr.write("Error: " + e.message)
    return -1

  check_modification.isModified(files)
  return 0

################################################################################
# help
################################################################################

HELP = \
r""" {0} [namespace,xml_path,include_path]
  xml_path      path to type system xml files
  include_path  path to include directory
  namespace     main namespace
"""

def help():
  script = os.path.basename(sys.argv[0])
  print(HELP.format(script))
  return

################################################################################
# __main__
################################################################################

if __name__ == "__main__":
  ret = main()
  if ret != 0:
    check_modification.removeModified()
  sys.exit(ret)
