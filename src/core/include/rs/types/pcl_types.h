/*
 * This file was generated by generate_typesystem.py.
 * Filename:    pcl_types
 * Name:        pcl
 * Description: No description given
 * Version:     1.0
 * Vendor:      None
 */
#ifndef __PCL_TYPES_H__
#define __PCL_TYPES_H__

#include <rs/feature_structure_proxy.h>
#include <rs/types/type_definitions.h>
#include <rs/types/ros_types.h>
#include <rs/types/core_types.h>

namespace rs
{

/*
 * No description given
 */
class PointIndices : public FeatureStructureProxy
{
private:
  void initFields()
  {
    header.init(this, "header");
    indices.init(this, "indices");
  }
public:
  // No description given
  ComplexFeatureStructureEntry<Header> header;
  // No description given
  ArrayFeatureStructureEntry<int> indices;

  PointIndices(const PointIndices &other) :
      FeatureStructureProxy(other)
  {
    initFields();
  }

  PointIndices(uima::FeatureStructure fs) :
      FeatureStructureProxy(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class PclFeature : public Annotation
{
private:
  void initFields()
  {
    feat_type.init(this, "feat_type");
    feature.init(this, "feature");
  }
public:
  // No description given
  FeatureStructureEntry<std::string> feat_type;
  // No description given
  ArrayFeatureStructureEntry<float> feature;

  PclFeature(const PclFeature &other) :
      Annotation(other)
  {
    initFields();
  }

  PclFeature(uima::FeatureStructure fs) :
      Annotation(fs)
  {
    initFields();
  }
};

/*
 * 3D bounding Box for clusters
 */
class BoundingBox3D : public FeatureStructureProxy
{
private:
  void initFields()
  {
    volume.init(this, "volume");
    width.init(this, "width");
    depth.init(this, "depth");
    height.init(this, "height");
  }
public:
  // volume of the box
  FeatureStructureEntry<float> volume;
  // width along the x axis
  FeatureStructureEntry<float> width;
  // depth along the y axis
  FeatureStructureEntry<float> depth;
  // height along the z axis
  FeatureStructureEntry<float> height;

  BoundingBox3D(const BoundingBox3D &other) :
      FeatureStructureProxy(other)
  {
    initFields();
  }

  BoundingBox3D(uima::FeatureStructure fs) :
      FeatureStructureProxy(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class ClusterPoints : public FeatureStructureProxy
{
private:
  void initFields()
  {
  }
public:

  ClusterPoints(const ClusterPoints &other) :
      FeatureStructureProxy(other)
  {
    initFields();
  }

  ClusterPoints(uima::FeatureStructure fs) :
      FeatureStructureProxy(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class PointCloud : public FeatureStructureProxy
{
private:
  void initFields()
  {
    points.init(this, "points");
    frame_id.init(this, "frame_id");
    point_type.init(this, "point_type");
    width.init(this, "width");
    height.init(this, "height");
    is_dense.init(this, "is_dense");
    header.init(this, "header");
  }
public:
  // Interpretation of this bytestream depends on the field PointType
  ArrayFeatureStructureEntry<char> points;
  // ROS frame id
  FeatureStructureEntry<std::string> frame_id;
  // PointType stored in points
  FeatureStructureEntry<std::string> point_type;
  // No description given
  FeatureStructureEntry<int> width;
  // No description given
  FeatureStructureEntry<int> height;
  // No description given
  FeatureStructureEntry<bool> is_dense;
  // No description given
  ComplexFeatureStructureEntry<Header> header;

  PointCloud(const PointCloud &other) :
      FeatureStructureProxy(other)
  {
    initFields();
  }

  PointCloud(uima::FeatureStructure fs) :
      FeatureStructureProxy(fs)
  {
    initFields();
  }
};

/*
 *  Semantic differentiation between a cloud that has been filtered  		    using Region filter or any other Point cloud fitler       
 */
class FilteredPointCloud : public PointCloud
{
private:
  void initFields()
  {
  }
public:

  FilteredPointCloud(const FilteredPointCloud &other) :
      PointCloud(other)
  {
    initFields();
  }

  FilteredPointCloud(uima::FeatureStructure fs) :
      PointCloud(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class StandaloneClusterPoints : public ClusterPoints
{
private:
  void initFields()
  {
    cloud.init(this, "cloud");
  }
public:
  // No description given
  ComplexFeatureStructureEntry<PointCloud> cloud;

  StandaloneClusterPoints(const StandaloneClusterPoints &other) :
      ClusterPoints(other)
  {
    initFields();
  }

  StandaloneClusterPoints(uima::FeatureStructure fs) :
      ClusterPoints(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class NormalsCloud : public PointCloud
{
private:
  void initFields()
  {
  }
public:

  NormalsCloud(const NormalsCloud &other) :
      PointCloud(other)
  {
    initFields();
  }

  NormalsCloud(uima::FeatureStructure fs) :
      PointCloud(fs)
  {
    initFields();
  }
};

/*
 * No description given
 */
class ReferenceClusterPoints : public ClusterPoints
{
private:
  void initFields()
  {
    indices.init(this, "indices");
    cloud.init(this, "cloud");
    normals.init(this, "normals");
  }
public:
  // No description given
  ComplexFeatureStructureEntry<PointIndices> indices;
  // No description given
  ComplexFeatureStructureEntry<PointCloud> cloud;
  // No description given
  ComplexFeatureStructureEntry<NormalsCloud> normals;

  ReferenceClusterPoints(const ReferenceClusterPoints &other) :
      ClusterPoints(other)
  {
    initFields();
  }

  ReferenceClusterPoints(uima::FeatureStructure fs) :
      ClusterPoints(fs)
  {
    initFields();
  }
};

}

TYPE_TRAIT(rs::PointIndices, RS_PCL_POINTINDICES)
TYPE_TRAIT(rs::PclFeature, RS_PCL_PCLFEATURE)
TYPE_TRAIT(rs::BoundingBox3D, RS_PCL_BOUNDINGBOX3D)
TYPE_TRAIT(rs::ClusterPoints, RS_PCL_CLUSTERPOINTS)
TYPE_TRAIT(rs::PointCloud, RS_PCL_POINTCLOUD)
TYPE_TRAIT(rs::FilteredPointCloud, RS_PCL_FILTEREDPOINTCLOUD)
TYPE_TRAIT(rs::StandaloneClusterPoints, RS_PCL_STANDALONECLUSTERPOINTS)
TYPE_TRAIT(rs::NormalsCloud, RS_PCL_NORMALSCLOUD)
TYPE_TRAIT(rs::ReferenceClusterPoints, RS_PCL_REFERENCECLUSTERPOINTS)

#endif /* __PCL_TYPES_H__ */
